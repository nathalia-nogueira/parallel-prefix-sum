ci1316  - PROGRAMAÇÃO PARALELA - 
2o semestre de 2025    
por W.Zola/UFPR

Lab 1: SomaDePrefixos-com-PThreads   (versão 1.2)  
----------------------------------
Histórico:
- v1.0 a versão inicial
- v1.1 trocamos para 8 milhoes de elementos
- v1.2 alterado abaixo onde foi indicado com (**)
        - mudada a especificacao para para fazer uso do
          vetor auxiliar PartialSum (com APENAS 1 elemento por thread)
          como mostrado no arquivo .txt descrevendo a ideia do algoritmo.
          Porque usaremos PartialSum ?
          R: porque SE NAO usar NENHUM o vetor auxiliar PartialSum
             voce teria de chamar uma barreira a mais e, nesse caso,
             seria pior o desempenho pois, provavelmente processar
             o pequeno vetor PartialSum é mais rápido do que sincronizar
             tendo de chamar uma barreira a MAIS.
             NOTE que conforme descrito no arquivo .txt descrevendo 
             a ideia do algoritmo, o algoritmo requer PELO MENOS
             a chamada de barreira UMA vez (alem da barreira do POOL
             de threads.)
         
  
Ideia do algoritmo apresentada em: 10/set/2025
Data do enunciado detalhado: 12/set/2025
Data da entrega Lab1: 03/out/2025 (serão 16 dias,...
                                 ...já descontados os dias da semana acadêmica!)


------- PASSOS PARA FAZER ESSE TRABALHO: -----------
O professor vai fornecer: 
 - o programa main completo
 - o script para rodar os experimentos
 - um Makefile exemplo do professor
 - uma planilha exemplo para voce rodar seus experimentos
   e incluir seus dados na pagina dadosV1
   ao incluir os seus dados a planilha já tem os gráficos
   MAS voce DEVE adaptar para ficar correto, SE NECESSARIO
   como incluir?
   * compile com comando make
   * rode o script do professor chamado roda.sh na sua máquina
     A MÁQUINA DEVE TER NO MÍNIMO 4 CORES E 8GB DE MEMÓRIA
     (voce DEVE ter um mínimo de processos rodando para não atrapalhar suas medidas)
     assim: 
         #rode com 8milhoes de elementos em máquina com 8GB assim
         ./roda.sh 8000000 
         
         
     esse script vai produzir a saida das experiencias para
     1 a 8 threads (10 vezes cada)
     Voce deve copiar (contol-C) a saida do script 
       na página dadosV1 na primeira celula dessa pagina
       fazer (control-V nessa célula)
       MARCANDO PARA A PLANILHA USAR COMO SEPARADORES OS CARACTERES []

     Ao fazer isso as tabelas estarão ok, e as cẽlulas também
     certifique-se que está tudo certo
     
     Aí basta voce ajustar as escalas dos gráficos 
     - clicando com mouse os eixos y (esquerdo ou direito) para
     e adequar as escalas, o prof. vai mostra na sala
     (ou já mostrou!)

Objetivos: 
// Obter uma implementação paralela MAIS eficiente 
//   com POOL de threads
//   para esse algoritmo "Soma de Prefixos" V1
//   em CPUs multicore usando PThreads

// será feita a soma de prefixos de 
//  um vetor de long long (ou seja, INTEIROS DE 64BITS) 
//  usando nThreads (definida via linha de comando)

// Para ESSE lab faremos:
//   a soma de prefixos será com a operação SOMA  (+)

// Funcionamento:
//  O programa deve funcionar para nTotalElements com nThreads 
//   Com: nTotalElements e nThreads obtidos da linha de comando
//   (assim como a versão feita em aula para a redução)
//  Utilização do programa:
//  usage: ./prefixSumPth <nTotalElements> <nThreads>

// ENTRADA para o algoritmo:
// A entrada para a função PthPrefixSum será: 
//   um vetor (GLOBAL) de nTotalElements números inteiros
//   chamado Vector
//   (nTotalElements obtido da linha de comando)
//
// Para esse teste o vetor NÂO será lido, 
//   - o vetor será preenchido sequencialmente pela função main
// Assim como nossa implementação anteriror, 
//   a inicializaçao do vetor de entrada (em main) deve ser
//
//      // initialize InitialVector
        for( long i = 0; i < nTotalElements; i++ ){
	        int r = rand();  // Returns a pseudo-random integer
	                     //    between 0 and RAND_MAX.
		InitialVector[i] = (r % 1000);
	}

// SAIDA do o algoritmo:
// A saída da função PthPrefixSum será: 
//   o PROPRIO vetor de entrada, um vetor (GLOBAL) de nTotalElements 
//   (números long long) 
//   chamado Vector
//   (nTotalElements obtido da linha de comando)
//

// A função a ser codificada por voce tem o protótipo
void ParallelPrefixSumPth( volatile TYPE *Vec, 
                           long nTotalElmts,
                           int nThreads );
// VEJA que deve ser feito a soma de prefixos
// "in place", (**) MUDADO AQUI na v1.2 (veja acima no histórico) 
//  APENAS usando o pequeno vetor auxiliar PartialSum,    
// (com APENAS 1 elemento por thread, como mostrado no arquivo .txt 
//   que descreve a ideia do algoritmo)
// para o cáculo da soma de prefixos                           
// DEVE ser feita com POOL de threads,
//  voce DEVE se basear no código dado pelo prof.
//  para a redução paralela com POOL de threads
//  ALTERANDO para fazer o prefix sum paralelo com
//  pthreads e pool de threads
// A implementação do POOL de threads DEVE seguir 
//   as ideias conforme feito para a redução paralela 
//   com POOL de threads                           

// ATENCAO: 
//  voce vai implementar sua funçao paralela
//  ParallelPrefixSumPth no codigo modelo dado pelo prof.
//  e incluir suas funçoes chamadas pelas SUAS threads
//  do POOL de threads,
//  SOBRE O PROGRAMA MAIN:
//  Esse NAO DEVE ser alterado,
//  SE voce alterar o programa main (especificamente)
//  dado pelo prof, DEVE ser um MINIMO de alteracoes
//  e APENAS se for MESMO necessario

// o programa deve calcular e imprimir 
//   o tempo e a vazão de calculo da Soma de Prefixos usando
//   a VERSÂO 1 do algoritmo usando as idéias descritas
//   no arquivo: 
//     ideia-do-algoritmo-paralelo-SomaDePrefixos-Pthreads-V1.2.txt
//     ou versao mais nova SE FOR colocada uma mais nova
//     na UFPR VIRTUAL o prof avisará


// Verificaçao de correção do programa: 
// ------------------------------------
// (item incluido na versao 1)
// o programa main, antes de terminar, deve verificar
//    se seu algoritmo paralelo gerando corretamente o vetor de saída
//    essa verificação DEVE ser feita de forma sequencial 
//    (ao final do main), INCLUINDO-SE O CÓDIGO ABAIXO
//    esse código roda apenas ao final, e NÃO deve influenciar
//    na medida de tempo feita para o algoritmo paralelo e
//    nem deve influenciar no cálculo e resultado de VAZAO reportada

void verifyPrefixSum( const TYPE *InputVec,       // original (initial) vector
                      volatile TYPE *prefixSumVec,   // prefixSum vector to be verified for correctness
                      long nTotalElmts )
{
    // codigo de verificação DISPONIBILIZADO 
    //   no programa inicial fornecido pelo prof. 
}


// O código ACIMA DEVE SER chamado ao final de main
   da seguinte maneira para verificar que seus algoritmos funcionam:
   
   verifyPrefixSum( InitVector, Vector, nTotalElements );


// rodar o programa 10 vezes obtendo o tempo MÉDIO
//  colocar TODOS os resultados em planilha

// Colocar na planilha exmplo dada (tabela) os tempos para
// 1, 2, 3, 4, 5, 6, 7, e 8 threads
// A última coluna da tabela (planilha) deve calcular 
//  a aceleração para 1, 2, 3, 4, 5, 6, 7, e 8 threads


// Entregar:
//  um tar.gz contendo:
//  -  o fonte da sua implementação em C, 
//  -  os scripts para compilar e rodar as experiências
//  -  a planilha preenchida com dados conforme descrito acima
//  -  Um arquivo com seu relatório descrevendo
//
//       a) como você implementou (descrever seu algoritmo)
//
//       b) a descrição do processador que voce usou, 
//          seu modelo e caracteristicas importantes para o experimento
//          COLOQUE EM APENDICE NO RELATORIO A SAIDA DO COMANDO lscpu

//          de preferência adicione também uma figura da 
//          topologia dos cores do processador obtida pelo programa lstopo

//       c) a descrição dos experimentos e como foram feitas as medidas
//       
//       d) a planilha de resultados sumarizando a vazao e aceleração
//       e) um gráfico (obtido de sua planilha) mostrando:
//            - no eixo X: o número de threads
//            - no eixo Y da esquerda: a vazao para cada número de threads
//                unir os pontos com linhas de uma certa cor C1 de sua preferência
//            - no eixo Y da direita: a aceleração para cada número de threads
//                unir os pontos com linhas de uma OUTRA cor C2 de sua preferência 

ENTREGA:
Em princípio o tar.gz deve ser entregue via upload na ufpr virtual
O professor deverá incluir (em breve) a opção para entrega do lab1 na ufpr virtual

--------------------------------------

